"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = __importStar(require("path"));
var assert = __importStar(require("assert"));
var prettier = __importStar(require("prettier"));
function runCommonTests(getTransformedText, options) {
    if (options === void 0) { options = {}; }
    describe("nameof", function () {
        describe("bad call expressions", function () {
            it("should throw if someone does not provide arguments or type arguments", function () {
                runThrowTest("nameof();", "Call expression must have one argument or type argument: nameof()");
            });
        });
        describe("argument", function () {
            it("should get the result of an identifier", function () {
                runTest("nameof(myObj);", "\"myObj\";");
            });
            it("should get the result of the this keyword", function () {
                runTest("nameof(this);", "\"this\";");
            });
            it("should get the result of a property access expression", function () {
                runTest("nameof(myObj.prop);", "\"prop\";");
            });
            it("should get the result of an expression with a parenthesized expression", function () {
                runTest("nameof((myObj).prop);", "\"prop\";");
            });
            it("should get the result of an expression with a type assertion", function () {
                runTest("nameof((myObj as any).prop);", "\"prop\";");
            });
            it("should get the result of a property access expression with null assertion operators", function () {
                runTest("nameof(myObj!.prop!);", "\"prop\";");
            });
            it("should get the result of an identifier with a dollar sign", function () {
                runTest("nameof(myObj.$prop);", "\"$prop\";");
            });
            it("should resolve to string when nesting nameofs", function () {
                runTest("nameof(nameof(testing));", "\"testing\";");
            });
        });
        describe("type parameter", function () {
            it("should get the result of an identifier", function () {
                runTest("nameof<Test>();", "\"Test\";");
            });
            it("should get the result of a fully qualified name", function () {
                runTest("nameof<This.Is.A.Test>();", "\"Test\";");
            });
            it("should get an identifier with a dollar sign", function () {
                runTest("nameof<Test$>();", "\"Test$\";");
            });
            it("should handle when someone uses an import type as not the last node", function () {
                runTest("nameof<import('test').prop>();", "\"prop\";");
            });
            it("should throw when someone only uses an import type", function () {
                runThrowTest("nameof<import('test')>();", getNotSupportedErrorText("import(\"test\")"));
            });
            it("should throw when someone only uses an import type with typeof", function () {
                runThrowTest("nameof<typeof import('test')>();", getNotSupportedErrorText("typeof import(\"test\")"));
            });
        });
        describe("computed properties", function () {
            it("should not allow a computed property to be at the end with a number", function () {
                runThrowTest("nameof(anyProp[0]);", getFirstAccessedPropertyMustNotBeComputedErrorText("anyProp[0]"));
            });
            it("should get after the period", function () {
                runTest("nameof(anyProp[0].prop);", "\"prop\";");
            });
            it("should get the string inside the computed property", function () {
                runTest("nameof(obj[\"prop\"]);", "\"prop\";");
            });
            it("should get the string inside the computed property for a function", function () {
                runTest("nameof<MyInterface>(i => i[\"prop\"]);", "\"prop\";");
            });
            it("should not allow a computed property to be at the end with a number when using a function", function () {
                runThrowTest("nameof<MyInterface>(i => i.prop[0]);", getFirstAccessedPropertyMustNotBeComputedErrorText("(i) => i.prop[0]"));
            });
            it("should not allow an identifier nested in a computed property", function () {
                runThrowTest("nameof<MyInterface>(i => i.prop[prop[0]]);", getFirstAccessedPropertyMustNotBeComputedErrorText("(i) => i.prop[prop[0]]"));
            });
        });
        describe("array", function () {
            it("should not allow only an array", function () {
                runThrowTest("nameof([0]);", getNotSupportedErrorText("[0]"));
            });
            it("should allow getting an array's property", function () {
                runTest("nameof([].length);", "\"length\";");
            });
        });
        describe("with function", function () {
            it("should get the last string", function () {
                runTest("nameof<MyInterface>(i => i.prop1.prop2);", "\"prop2\";");
            });
            it("should get from the return statement", function () {
                runTest("nameof<MyInterface>(i => { console.log('test'); return i.prop1.prop2; });", "\"prop2\";");
            });
            it("should handle when someone uses an import type", function () {
                runTest("nameof<import('test')>(x => x.Foo);", "\"Foo\";");
            });
            it("should get when using an element access expression directly on the object", function () {
                runTest("nameof<MyInterface>(i => i[\"prop1\"]);", "\"prop1\";");
            });
            it("should throw when using an element access expression directly on the object and it is not a string", function () {
                runThrowTest("nameof<MyInterface>(i => i[0]);", getFirstAccessedPropertyMustNotBeComputedErrorText("(i) => i[0]"));
            });
            it("should throw when the function doesn't have a period", function () {
                runThrowTest("nameof<MyInterface>(i => i);", "A property must be accessed on the object: (i) => i");
            });
            it("should throw when the function doesn't have a return statement", function () {
                var errorPrefix = "Cound not find return statement with an expression in function expression: ";
                var possibleMessages = [
                    errorPrefix + "{ i; }",
                    errorPrefix + "{\n    i;\n}"
                ];
                runThrowTest("nameof<MyInterface>(i => { i; });", possibleMessages);
            });
        });
        describe("literals", function () {
            it("should leave the string literal as-is", function () {
                runTest("nameof(\"test\");", "\"test\";");
            });
            it("should transform a numeric literal as a string", function () {
                runTest("nameof(5);", "\"5\";");
            });
        });
        describe("interpolate", function () {
            it("should throw when providing nameof.interpolate to nameof", function () {
                runThrowTest("nameof(nameof.interpolate(5));", [
                    getNotSupportedErrorText("nameof.interpolate(5)"),
                    getUnusedNameofInterpolateErrorText("5")
                ]);
            });
        });
        describe("template expression", function () {
            it("should return a no substitution template literal", function () {
                runTest("nameof(`testing`);", "`testing`;");
            });
            it("should return the template expression when it has only a template tail", function () {
                runTest("nameof(`testing${test}final`);", "`testing${test}final`;");
            });
            it("should return the template expression when it has a template middle", function () {
                runTest("nameof(`testing${other}asdf${test}${asdf}final`);", "`testing${other}asdf${test}${asdf}final`;");
            });
            it("should return the template expression when it starts and ends with one", function () {
                runTest("nameof(`${other}`);", "`${other}`;");
            });
            it("should return the template expression when it starts and ends with multiple", function () {
                runTest("nameof(`${other}${asdf}${test}`);", "`${other}${asdf}${test}`;");
            });
            it("should throw when a nameof.interpolate is not used", function () {
                runThrowTest("nameof(`${nameof.interpolate(other)}`);", getUnusedNameofInterpolateErrorText("other"));
            });
        });
        describe("other", function () {
            it("should ignore spread syntax", function () {
                runTest("nameof(...test);", "\"test\";");
            });
        });
    });
    describe("nameof.full", function () {
        describe("bad call expressions", function () {
            it("should throw if someone does not provide arguments or type arguments", function () {
                runThrowTest("nameof.full();", "Unsupported use of nameof.full: nameof.full()");
            });
        });
        describe("argument", function () {
            it("should include everything when no count arg is provided", function () {
                runTest("nameof.full(obj.prop.other);", "\"obj.prop.other\";");
            });
            it("should not include null assertion operators", function () {
                runTest("nameof.full(obj!.prop!.other!);", "\"obj.prop.other\";");
            });
            it("should not include null assertion operators when also using element access expressions", function () {
                runTest("nameof.full(obj!.prop![0].other!);", "\"obj.prop[0].other\";");
            });
            it("should escape string literals in element access expressions", function () {
                runTest("nameof.full(obj.prop[\"other\"]);", "\"obj.prop[\\\"other\\\"]\";");
            });
            it("should allow using a period index", function () {
                runTest("nameof.full(MyTest.Test.This, 1);", "\"Test.This\";");
            });
            it("should allow using a period index of 0", function () {
                runTest("nameof.full(MyTest.Test.This, 0);", "\"MyTest.Test.This\";");
            });
            it("should allow using a period index up to its max value", function () {
                runTest("nameof.full(MyTest.Test.This, 2);", "\"This\";");
            });
            it("should allow using a negative period index", function () {
                runTest("nameof.full(MyTest.Test.This, -1);", "\"This\";");
            });
            it("should allow using a negative period index to its max value", function () {
                runTest("nameof.full(MyTest.Test.This, -3);", "\"MyTest.Test.This\";");
            });
            it("should throw when the periodIndex is not a number literal", function () {
                runThrowTest("nameof.full(MyTest.Test, 'test')", "Expected count to be a number, but was: \"test\"");
            });
            it("should throw when the periodIndex is greater than the number of periods", function () {
                runThrowTest("nameof.full(MyTest.Test, 2)", "Count of 2 was larger than max count of 1: nameof.full(MyTest.Test, 2)");
            });
            it("should throw when the absolute value of the negative periodIndex is greater than the number of periods + 1", function () {
                runThrowTest("nameof.full(MyTest.Test, -3)", "Count of -3 was larger than max count of -2: nameof.full(MyTest.Test, -3)");
            });
            it("should resolve to string when nesting nameofs", function () {
                runTest("nameof.full(nameof(testing));", "\"testing\";");
            });
            it("should get the result of the super keyword", function () {
                runTest("class Test {\n  constructor() {\n    nameof.full(super.test);\n  }\n}", "class Test {\n  constructor() {\n    \"super.test\";\n  }\n}");
            });
        });
        describe("type parameter", function () {
            it("should include everything when no count arg is provided", function () {
                runTest("nameof.full<Some.Test.Name>();", "\"Some.Test.Name\";");
            });
            it("should allow using a period index", function () {
                runTest("nameof.full<MyTest.Test.This>(1);", "\"Test.This\";");
            });
            it("should allow using a period index of 0", function () {
                runTest("nameof.full<MyTest.Test.This>(0);", "\"MyTest.Test.This\";");
            });
            it("should allow using a period index up to its max value", function () {
                runTest("nameof.full<MyTest.Test.This>(2);", "\"This\";");
            });
            it("should allow using a negative period index", function () {
                runTest("nameof.full<MyTest.Test.This>(-1);", "\"This\";");
            });
            it("should allow using a negative period index to its max value", function () {
                runTest("nameof.full<MyTest.Test.This>(-3);", "\"MyTest.Test.This\";");
            });
            it("should throw when the periodIndex is not a number literal", function () {
                runThrowTest("nameof.full<MyTest.Test>('test')", "Expected count to be a number, but was: \"test\"");
            });
            it("should throw when the periodIndex is greater than the number of periods", function () {
                runThrowTest("nameof.full<MyTest.Test>(2)", "Count of 2 was larger than max count of 1: nameof.full<MyTest.Test>(2)");
            });
            it("should throw when the absolute value of the negative periodIndex is greater than the number of periods + 1", function () {
                runThrowTest("nameof.full<MyTest.Test>(-3)", "Count of -3 was larger than max count of -2: nameof.full<MyTest.Test>(-3)");
            });
            it("should throw when someone uses an import type", function () {
                runThrowTest("nameof.full<import('test').other.test>();", getNotSupportedErrorText("import(\"test\").other.test"));
            });
        });
        describe("arrays", function () {
            it("should include the brackets", function () {
                runTest("nameof.full(anyProp[0].myProp);", "\"anyProp[0].myProp\";");
            });
        });
        describe("with function", function () {
            it("should get the text", function () {
                runTest("nameof.full<MyInterface>(i => i.prop1.prop2);", "\"prop1.prop2\";");
            });
            it("should get the text without the null assertion operator", function () {
                runTest("nameof.full<MyInterface>(i => i.prop1!.prop2!);", "\"prop1.prop2\";");
            });
            it("should get the text when there's a trailing comma with whitespace", function () {
                runTest("nameof.full<IState>(state => state.field.dates, );", "\"field.dates\";");
            });
            it("should get the text when using a function", function () {
                runTest("nameof.full<MyInterface>(function(i) { return i.prop1.prop2; });", "\"prop1.prop2\";");
            });
            it("should get the text when providing a period", function () {
                runTest("nameof.full<MyInterface>(i => i.prop1.prop2, 0);", "\"prop1.prop2\";");
                runTest("nameof.full<MyInterface>(i => i.prop1.prop2, 1);", "\"prop2\";");
                runTest("nameof.full<MyInterface>(i => i.prop1.prop2.prop3, -1);", "\"prop3\";");
            });
            it("should throw when the function doesn't have a period", function () {
                runThrowTest("nameof.full<MyInterface>(i => i);", "A property must be accessed on the object: (i) => i");
            });
            it("should throw when someone nests a function within a function", function () {
                runThrowTest("nameof.full<MyInterface>(i => () => 5);", "A property must be accessed on the object: (i) => () => 5");
            });
        });
        describe("interpolate", function () {
            var singleArgumentErrorMessage = "Unexpected scenario where a nameof.interpolate function did not have a single argument.";
            it("should interpolate the provided expression", function () {
                runTest("nameof.full(Test.Other[nameof.interpolate(other)]);", "`Test.Other[${other}]`;");
            });
            it("should interpolate when using a function", function () {
                runTest("nameof.full<a>(a => a.b.c[nameof.interpolate(index)].d);", "`b.c[${index}].d`;");
            });
            it("should throw when the interpolate function has zero arguments", function () {
                runThrowTest("nameof.full(Test.Other[nameof.interpolate()]);", singleArgumentErrorMessage);
            });
            it("should throw when the interpolate function has multiple arguments", function () {
                runThrowTest("nameof.full(Test.Other[nameof.interpolate(test, test)]);", singleArgumentErrorMessage);
            });
            it("should throw when a nameof.interpolate is not used inside a nameof.full", function () {
                runThrowTest("nameof.interpolate(some.expression);", getUnusedNameofInterpolateErrorText("some.expression"));
            });
        });
    });
    describe("toArray", function () {
        it("should return an array of values when given a function that returns an array as input", function () {
            runTest("nameof.toArray<MyInterface>(o => [o.Prop1, o.Prop2, o.Prop3]);", "[\"Prop1\", \"Prop2\", \"Prop3\"];");
        });
        it("should return an array of values when given multiple arguments", function () {
            runTest("nameof.toArray(myObject.Prop1, otherObject.Prop2);", "[\"Prop1\", \"Prop2\"];");
        });
        it("should return an array with a single element if a non-function argument is passed", function () {
            runTest("nameof.toArray(myObject.Prop1);", "[\"Prop1\"];");
        });
        it("should support nested nameof calls", function () {
            runTest("nameof.toArray(nameof.full(Some.Qualified.Name), Some.Qualified.Name);", "[\"Some.Qualified.Name\", \"Name\"];");
        });
        it("should support a non-arrow function expression", function () {
            runTest("nameof.toArray<MyInterface>(function(o) { return [o.Prop1, o.Prop2]; });", "[\"Prop1\", \"Prop2\"];");
        });
        it("should throw when the function argument does not return an array", function () {
            runThrowTest("nameof.toArray<MyInterface>(o => o.Prop1);", "Unsupported toArray call expression. An array must be returned by the provided function: nameof.toArray<MyInterface>((o) => o.Prop1)");
        });
        it("should throw when no arguments are provided", function () {
            runThrowTest("nameof.toArray<MyInterface>();", "Unable to parse call expression. No arguments provided: nameof.toArray<MyInterface>()");
        });
    });
    describe("split", function () {
        it("should return an array of values where each element is a subsequent part of the path provided", function () {
            runTest("nameof.split<MyInterface>(o => o.Prop1.Prop2.Prop3);", "[\"Prop1\", \"Prop2\", \"Prop3\"];");
        });
        it("should return an array of values where each element is a subsequent part of the path provided", function () {
            runTest("nameof.split(o.Prop1.Prop2.Prop3);", "[\"o\", \"Prop1\", \"Prop2\", \"Prop3\"];");
        });
        it("should allow using a period index", function () {
            runTest("nameof.split(MyTest.Test.This, 1);", "[\"Test\", \"This\"];");
        });
        it("should allow using a period index of 0", function () {
            runTest("nameof.split(MyTest.Test.This, 0);", "[\"MyTest\", \"Test\", \"This\"];");
        });
        it("should allow using a period index up to its max value", function () {
            runTest("nameof.split(MyTest.Test.This, 2);", "[\"This\"];");
        });
        it("should allow using a negative period index", function () {
            runTest("nameof.split(MyTest.Test.This, -1);", "[\"This\"];");
        });
        it("should allow using a negative period index to its max value", function () {
            runTest("nameof.split(MyTest.Test.This, -3);", "[\"MyTest\", \"Test\", \"This\"];");
        });
        it("should throw when the periodIndex is not a number literal", function () {
            runThrowTest("nameof.split(MyTest.Test, 'test')", "Expected count to be a number, but was: \"test\"");
        });
        it("should throw when the periodIndex is greater than the number of periods", function () {
            runThrowTest("nameof.split(MyTest.Test, 2)", "Count of 2 was larger than max count of 1: nameof.split(MyTest.Test, 2)");
        });
        it("should throw when the absolute value of the negative periodIndex is greater than the number of periods + 1", function () {
            runThrowTest("nameof.split(MyTest.Test, -3)", "Count of -3 was larger than max count of -2: nameof.split(MyTest.Test, -3)");
        });
    });
    describe("general", function () {
        it("should error when specifying a different nameof property", function () {
            runThrowTest("nameof.nonExistent()", "Unsupported nameof call expression with property 'nonExistent': nameof.nonExistent()");
        });
        it("should replace handling comments", function () {
            var input = "nameof(window);\n// nameof(window);\nnameof(window);\n/* nameof(window); nameof(window); */\nnameof(window);\n";
            var expected = "\"window\";\n// nameof(window);\n\"window\";\n/* nameof(window); nameof(window); */\n\"window\";\n";
            runTest(input, expected);
        });
        it("should replace handling strings", function () {
            var input = "nameof(window);\nconst t = /`/g;\n`nameof(window); /\n${nameof(window)}\n${nameof(alert)}\nnameof(window);\n`; //test\n\"nameof(window);\";\n\"\\\"nameof(window);\";\n'nameof(window);';\n'\\'\\\"nameof(window);';\n\"C:\\\\\";\nnameof(window);\n`${() => {\n  nameof(console);\n}}`;\n";
            var expected = "\"window\";\nconst t = /`/g;\n`nameof(window); /\n${\"window\"}\n${\"alert\"}\nnameof(window);\n`; //test\n\"nameof(window);\";\n\"\\\"nameof(window);\";\n\"nameof(window);\";\n'\\'\\\"nameof(window);';\n\"C:\\\\\";\n\"window\";\n`${() => {\n  \"console\";\n}}`;\n";
            runTest(input, expected);
        });
        it("should handle division operators", function () {
            var input = "const t = 2 / 1;\nnameof(testing);";
            var expected = "const t = 2 / 1;\n\"testing\";";
            runTest(input, expected);
        });
    });
    function runTest(text, expected) {
        if (options.commonPrefix != null)
            text = options.commonPrefix + text;
        var result = getTransformedText(text);
        if (!expected.endsWith("\n"))
            expected += "\n";
        assert.equal(prettier.format(result, { parser: "typescript" }), expected);
    }
    function runThrowTest(text, possibleExpectedMessages) {
        if (options.commonPrefix != null)
            text = options.commonPrefix + text;
        var transformedText;
        try {
            transformedText = getTransformedText(text);
        }
        catch (ex) {
            possibleExpectedMessages = getPossibleExpectedMessages();
            var actualMessage = ex.message;
            for (var _i = 0, possibleExpectedMessages_1 = possibleExpectedMessages; _i < possibleExpectedMessages_1.length; _i++) {
                var message = possibleExpectedMessages_1[_i];
                if (message === actualMessage)
                    return;
            }
            throw new Error("Expected the error message of " + actualMessage + " to equal one of the following messages: " + possibleExpectedMessages);
        }
        throw new Error("Expected to throw, but returned: " + transformedText);
        function getPossibleExpectedMessages() {
            var result = getAsArray();
            for (var i = result.length - 1; i >= 0; i--) {
                var originalText = result[i];
                result[i] = "[ts-nameof]: " + originalText;
                result.push("[ts-nameof:/file.ts]: " + originalText);
                result.push("[ts-nameof:" + path.resolve(__dirname, "../../transforms-babel/src/tests/test.ts") + "]: " + originalText);
                result.push("./ts-nameof.macro: [ts-nameof]: " + originalText);
            }
            return result;
            function getAsArray() {
                if (typeof possibleExpectedMessages === "string")
                    return [possibleExpectedMessages];
                return possibleExpectedMessages;
            }
        }
    }
}
exports.runCommonTests = runCommonTests;
function getFirstAccessedPropertyMustNotBeComputedErrorText(nodeText) {
    return "First accessed property must not be computed except if providing a string: " + nodeText;
}
function getNotSupportedErrorText(nodeText) {
    return "The node `" + nodeText + "` is not supported in this scenario.";
}
function getUnusedNameofInterpolateErrorText(nodeText) {
    return "Found a nameof.interpolate that did not exist within a nameof.full call expression: nameof.interpolate(" + nodeText + ")";
}
